{"version":3,"file":"ap.controller.js","sources":["../node_modules/.pnpm/@rollup+plugin-typescript@11.1.3_rollup@3.28.1_tslib@2.6.2_typescript@5.2.2/node_modules/tslib/tslib.es6.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/tag-observer.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/get-property-descriptor.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/mark.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/ability.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/controllable.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/dasherize.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/targetable.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/attrable.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/actionable.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/controller.js","../node_modules/.pnpm/@github+catalyst@2.0.0-alpha1/node_modules/@github/catalyst/lib/register.js"],"sourcesContent":["/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport function __addDisposableResource(env, value, async) {\r\n    if (value !== null && value !== void 0) {\r\n        if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\r\n        var dispose;\r\n        if (async) {\r\n            if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\r\n            dispose = value[Symbol.asyncDispose];\r\n        }\r\n        if (dispose === void 0) {\r\n            if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\r\n            dispose = value[Symbol.dispose];\r\n        }\r\n        if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\r\n        env.stack.push({ value: value, dispose: dispose, async: async });\r\n    }\r\n    else if (async) {\r\n        env.stack.push({ async: true });\r\n    }\r\n    return value;\r\n}\r\n\r\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\r\n\r\nexport function __disposeResources(env) {\r\n    function fail(e) {\r\n        env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\r\n        env.hasError = true;\r\n    }\r\n    function next() {\r\n        while (env.stack.length) {\r\n            var rec = env.stack.pop();\r\n            try {\r\n                var result = rec.dispose && rec.dispose.call(rec.value);\r\n                if (rec.async) return Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\r\n            }\r\n            catch (e) {\r\n                fail(e);\r\n            }\r\n        }\r\n        if (env.hasError) throw env.error;\r\n    }\r\n    return next();\r\n}\r\n\r\nexport default {\r\n    __extends: __extends,\r\n    __assign: __assign,\r\n    __rest: __rest,\r\n    __decorate: __decorate,\r\n    __param: __param,\r\n    __metadata: __metadata,\r\n    __awaiter: __awaiter,\r\n    __generator: __generator,\r\n    __createBinding: __createBinding,\r\n    __exportStar: __exportStar,\r\n    __values: __values,\r\n    __read: __read,\r\n    __spread: __spread,\r\n    __spreadArrays: __spreadArrays,\r\n    __spreadArray: __spreadArray,\r\n    __await: __await,\r\n    __asyncGenerator: __asyncGenerator,\r\n    __asyncDelegator: __asyncDelegator,\r\n    __asyncValues: __asyncValues,\r\n    __makeTemplateObject: __makeTemplateObject,\r\n    __importStar: __importStar,\r\n    __importDefault: __importDefault,\r\n    __classPrivateFieldGet: __classPrivateFieldGet,\r\n    __classPrivateFieldSet: __classPrivateFieldSet,\r\n    __classPrivateFieldIn: __classPrivateFieldIn,\r\n    __addDisposableResource: __addDisposableResource,\r\n    __disposeResources: __disposeResources,\r\n};\r\n","function closestShadowPiercing(el, tagName) {\n    const closest = el.closest(tagName);\n    if (!closest) {\n        const shadow = el.getRootNode();\n        if (!(shadow instanceof ShadowRoot))\n            return null;\n        return shadow.host.closest(tagName);\n    }\n    return closest;\n}\nexport const parseElementTags = (el, tag, parse) => (el.getAttribute(tag) || '')\n    .trim()\n    .split(/\\s+/g)\n    .map((tagPart) => parse(tagPart));\nconst registry = new Map();\nconst observer = new MutationObserver((mutations) => {\n    for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n            const tag = mutation.attributeName;\n            const el = mutation.target;\n            if (el instanceof Element && registry.has(tag)) {\n                const [parse, found] = registry.get(tag);\n                for (const [tagName, ...meta] of parseElementTags(el, tag, parse)) {\n                    const controller = closestShadowPiercing(el, tagName);\n                    if (controller)\n                        found(el, controller, tag, ...meta);\n                }\n            }\n        }\n        else if (mutation.addedNodes.length) {\n            for (const node of mutation.addedNodes) {\n                if (node instanceof Element)\n                    observeElementForTags(node);\n            }\n        }\n    }\n});\nexport const registerTag = (tag, parse, found) => {\n    if (registry.has(tag))\n        throw new Error('duplicate tag');\n    registry.set(tag, [parse, found]);\n};\nexport const observeElementForTags = (root) => {\n    for (const [tag, [parse, found]] of registry) {\n        for (const el of root.querySelectorAll(`[${tag}]`)) {\n            for (const [tagName, ...meta] of parseElementTags(el, tag, parse)) {\n                const controller = closestShadowPiercing(el, tagName);\n                if (controller)\n                    found(el, controller, tag, ...meta);\n            }\n        }\n        if (root instanceof Element && root.hasAttribute(tag)) {\n            for (const [tagName, ...meta] of parseElementTags(root, tag, parse)) {\n                const controller = closestShadowPiercing(root, tagName);\n                if (controller)\n                    found(root, controller, tag, ...meta);\n            }\n        }\n    }\n    observer.observe(root instanceof Element ? root.ownerDocument : root, {\n        childList: true,\n        subtree: true,\n        attributeFilter: Array.from(registry.keys())\n    });\n};\n//# sourceMappingURL=tag-observer.js.map","export const getPropertyDescriptor = (instance, key) => {\n    while (instance) {\n        const descriptor = Object.getOwnPropertyDescriptor(instance, key);\n        if (descriptor)\n            return descriptor;\n        instance = Object.getPrototypeOf(instance);\n    }\n};\n//# sourceMappingURL=get-property-descriptor.js.map","import { getPropertyDescriptor } from './get-property-descriptor.js';\nconst getType = (descriptor) => {\n    if (descriptor) {\n        if (typeof descriptor.value === 'function')\n            return 'method';\n        if (typeof descriptor.get === 'function')\n            return 'getter';\n        if (typeof descriptor.set === 'function')\n            return 'setter';\n    }\n    return 'field';\n};\nexport function createMark(validate, initialize) {\n    const marks = new WeakMap();\n    const get = (proto) => {\n        if (!marks.has(proto)) {\n            const parent = Object.getPrototypeOf(proto);\n            marks.set(proto, new Set(parent ? get(parent) || [] : []));\n        }\n        return marks.get(proto);\n    };\n    const marker = (proto, name, descriptor) => {\n        if (get(proto).has(name))\n            return;\n        validate({ name, kind: getType(descriptor) });\n        get(proto).add(name);\n    };\n    marker.static = Symbol();\n    const getMarks = (instance) => {\n        const proto = Object.getPrototypeOf(instance);\n        for (const key of proto.constructor[marker.static] || []) {\n            marker(proto, key, Object.getOwnPropertyDescriptor(proto, key));\n        }\n        return new Set(get(proto));\n    };\n    return [\n        marker,\n        getMarks,\n        (instance) => {\n            for (const name of getMarks(instance)) {\n                const access = getPropertyDescriptor(instance, name) || {\n                    value: void 0,\n                    configurable: true,\n                    writable: true,\n                    enumerable: true\n                };\n                const newDescriptor = initialize(instance, { name, kind: getType(access), access }) || access;\n                Object.defineProperty(instance, name, Object.assign({ configurable: true, enumerable: true }, newDescriptor));\n            }\n        }\n    ];\n}\n//# sourceMappingURL=mark.js.map","const abilityMarkers = new WeakMap();\nexport const createAbility = (decorate) => {\n    return (Class) => {\n        const markers = abilityMarkers.get(Class);\n        if (markers?.has(decorate))\n            return Class;\n        const NewClass = decorate(Class);\n        Object.defineProperty(NewClass, 'name', { value: Class.name });\n        const newMarkers = new Set(markers);\n        newMarkers.add(decorate);\n        abilityMarkers.set(NewClass, newMarkers);\n        return NewClass;\n    };\n};\n//# sourceMappingURL=ability.js.map","import { createAbility } from './ability.js';\nexport const attachShadowCallback = Symbol();\nexport const attachInternalsCallback = Symbol();\nconst shadows = new WeakMap();\nconst internals = new WeakMap();\nconst internalsCalled = new WeakSet();\nexport const controllable = createAbility((Class) => class extends Class {\n    // TS mandates Constructors that get mixins have `...args: any[]`\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    constructor(...args) {\n        super(...args);\n        const shadowRoot = this.shadowRoot;\n        if (shadowRoot && shadowRoot !== shadows.get(this))\n            this[attachShadowCallback](shadowRoot);\n        if (!internalsCalled.has(this)) {\n            try {\n                this.attachInternals();\n            }\n            catch {\n                // Ignore errors\n            }\n        }\n    }\n    connectedCallback() {\n        this.setAttribute('data-catalyst', '');\n        super.connectedCallback?.();\n    }\n    attachShadow(...args) {\n        const shadowRoot = super.attachShadow(...args);\n        this[attachShadowCallback](shadowRoot);\n        return shadowRoot;\n    }\n    [attachShadowCallback](shadowRoot) {\n        shadows.set(this, shadowRoot);\n    }\n    attachInternals() {\n        if (internals.has(this) && !internalsCalled.has(this)) {\n            internalsCalled.add(this);\n            return internals.get(this);\n        }\n        const elementInternals = super.attachInternals();\n        this[attachInternalsCallback](elementInternals);\n        internals.set(this, elementInternals);\n        return elementInternals;\n    }\n    [attachInternalsCallback](elementInternals) {\n        const shadowRoot = elementInternals.shadowRoot;\n        if (shadowRoot && shadowRoot !== shadows.get(this)) {\n            this[attachShadowCallback](shadowRoot);\n        }\n    }\n});\n//# sourceMappingURL=controllable.js.map","export const dasherize = (str) => String(typeof str === 'symbol' ? str.description : str)\n    .replace(/([A-Z]($|[a-z]))/g, '-$1')\n    .replace(/--/g, '-')\n    .replace(/^-|-$/, '')\n    .toLowerCase();\nexport const mustDasherize = (str, type = 'property') => {\n    const dashed = dasherize(str);\n    if (!dashed.includes('-')) {\n        throw new DOMException(`${type}: ${String(str)} is not a valid ${type} name`, 'SyntaxError');\n    }\n    return dashed;\n};\n//# sourceMappingURL=dasherize.js.map","import { registerTag, observeElementForTags } from './tag-observer.js';\nimport { createMark } from './mark.js';\nimport { controllable, attachShadowCallback } from './controllable.js';\nimport { dasherize } from './dasherize.js';\nimport { createAbility } from './ability.js';\nconst targetChangedCallback = Symbol();\nconst targetsChangedCallback = Symbol();\nconst [target, getTarget, initializeTarget] = createMark(({ name, kind }) => {\n    if (kind === 'getter')\n        throw new Error(`@target cannot decorate get ${String(name)}`);\n}, (instance, { name, access }) => {\n    const selector = [\n        `[data-target~=\"${instance.tagName.toLowerCase()}.${dasherize(name)}\"]`,\n        `[data-target~=\"${instance.tagName.toLowerCase()}.${String(name)}\"]`\n    ];\n    const find = findTarget(instance, selector.join(', '), false);\n    return {\n        get: find,\n        set: () => {\n            if (access?.set)\n                access.set.call(instance, find());\n        }\n    };\n});\nconst [targets, getTargets, initializeTargets] = createMark(({ name, kind }) => {\n    if (kind === 'getter')\n        throw new Error(`@target cannot decorate get ${String(name)}`);\n}, (instance, { name, access }) => {\n    const selector = [\n        `[data-targets~=\"${instance.tagName.toLowerCase()}.${dasherize(name)}\"]`,\n        `[data-targets~=\"${instance.tagName.toLowerCase()}.${String(name)}\"]`\n    ];\n    const find = findTarget(instance, selector.join(', '), true);\n    return {\n        get: find,\n        set: () => {\n            if (access?.set)\n                access.set.call(instance, find());\n        }\n    };\n});\nfunction setTarget(el, controller, tag, key) {\n    const get = tag === 'data-targets' ? getTargets : getTarget;\n    if (controller instanceof ShadowRoot) {\n        controller = controllers.get(controller);\n    }\n    if (controller && get(controller)?.has(key)) {\n        ;\n        controller[key] = {};\n    }\n}\nregisterTag('data-target', (str) => str.split('.'), setTarget);\nregisterTag('data-targets', (str) => str.split('.'), setTarget);\nconst shadows = new WeakMap();\nconst controllers = new WeakMap();\nconst findTarget = (controller, selector, many) => () => {\n    const nodes = [];\n    const shadow = shadows.get(controller);\n    if (shadow) {\n        for (const el of shadow.querySelectorAll(selector)) {\n            if (!el.closest(controller.tagName)) {\n                nodes.push(el);\n                if (!many)\n                    break;\n            }\n        }\n    }\n    if (many || !nodes.length) {\n        for (const el of controller.querySelectorAll(selector)) {\n            if (el.closest(controller.tagName) === controller) {\n                nodes.push(el);\n                if (!many)\n                    break;\n            }\n        }\n    }\n    return many ? nodes : nodes[0];\n};\nexport { target, getTarget, targets, getTargets, targetChangedCallback, targetsChangedCallback };\nexport const targetable = createAbility((Class) => class extends controllable(Class) {\n    constructor() {\n        super();\n        observeElementForTags(this);\n        initializeTarget(this);\n        initializeTargets(this);\n    }\n    [targetChangedCallback]() {\n        return;\n    }\n    [targetsChangedCallback]() {\n        return;\n    }\n    [attachShadowCallback](root) {\n        super[attachShadowCallback]?.(root);\n        shadows.set(this, root);\n        controllers.set(root, this);\n        observeElementForTags(root);\n    }\n});\n//# sourceMappingURL=targetable.js.map","import { controllable } from './controllable.js';\nimport { dasherize, mustDasherize } from './dasherize.js';\nimport { createMark } from './mark.js';\nimport { createAbility } from './ability.js';\nconst attrChangedCallback = Symbol();\nconst Identity = (v) => v;\nlet setFromMutation = false;\nconst attrs = new WeakMap();\nconst handleMutations = (mutations) => {\n    for (const mutation of mutations) {\n        if (mutation.type === 'attributes') {\n            const name = mutation.attributeName;\n            const el = mutation.target;\n            const key = attrs.get(el)?.get(name);\n            if (key) {\n                setFromMutation = true;\n                el[key] = el.getAttribute(name);\n                setFromMutation = false;\n            }\n        }\n    }\n};\nconst observer = new MutationObserver(handleMutations);\nconst [attr, getAttr, initializeAttrs] = createMark(({ name }) => mustDasherize(name, '@attr'), (instance, { name, kind, access }) => {\n    let cast = Identity;\n    let initialValue;\n    if (access.get) {\n        initialValue = access.get.call(instance);\n    }\n    else if ('value' in access && kind !== 'method') {\n        initialValue = access.value;\n    }\n    let value = initialValue;\n    const attributeName = dasherize(name);\n    const setCallback = (kind === 'method' ? access.value : access.set) || Identity;\n    const getCallback = access.get || (() => value);\n    if (!attrs.get(instance))\n        attrs.set(instance, new Map());\n    attrs.get(instance).set(attributeName, name);\n    if (typeof value === 'number') {\n        cast = Number;\n    }\n    else if (typeof value === 'boolean') {\n        cast = Boolean;\n    }\n    else if (typeof value === 'string') {\n        cast = String;\n    }\n    const queue = new Map();\n    const requestAttrChanged = async (newValue) => {\n        queue.set(name, newValue);\n        if (queue.size > 1)\n            return;\n        await Promise.resolve();\n        const changed = new Map(queue);\n        queue.clear();\n        instance[attrChangedCallback](changed);\n    };\n    return {\n        get() {\n            const has = instance.hasAttribute(attributeName);\n            if (has) {\n                return cast === Boolean ? has : cast(instance.getAttribute(attributeName));\n            }\n            return cast(getCallback.call(instance));\n        },\n        set(newValue) {\n            const isInitial = newValue === null;\n            if (isInitial)\n                newValue = initialValue;\n            const same = Object.is(value, newValue);\n            value = newValue;\n            setCallback.call(instance, value);\n            if (setFromMutation || same || isInitial)\n                return;\n            requestAttrChanged(newValue);\n        }\n    };\n});\nexport { attr, getAttr, attrChangedCallback };\nexport const attrable = createAbility((Class) => class extends controllable(Class) {\n    constructor() {\n        super();\n        initializeAttrs(this);\n        observer.observe(this, { attributeFilter: Array.from(getAttr(this)).map(dasherize) });\n    }\n    [attrChangedCallback](changed) {\n        if (!this.isConnected)\n            return;\n        for (const [name, value] of changed) {\n            if (typeof value === 'boolean') {\n                this.toggleAttribute(dasherize(name), value);\n            }\n            else {\n                this.setAttribute(dasherize(name), String(value));\n            }\n        }\n    }\n});\n//# sourceMappingURL=attrable.js.map","import { registerTag, observeElementForTags, parseElementTags } from './tag-observer.js';\nimport { controllable, attachShadowCallback } from './controllable.js';\nimport { createAbility } from './ability.js';\nconst parseActionAttribute = (tag) => {\n    const eventSep = tag.lastIndexOf(':');\n    const methodSep = Math.max(0, tag.lastIndexOf('#')) || tag.length;\n    return [tag.slice(eventSep + 1, methodSep), tag.slice(0, eventSep), tag.slice(methodSep + 1) || 'handleEvent'];\n};\nregisterTag('data-action', parseActionAttribute, (el, controller, tag, event) => {\n    el.addEventListener(event, handleEvent);\n});\nconst actionables = new WeakSet();\n// Bind a single function to all events to avoid anonymous closure performance penalty.\nfunction handleEvent(event) {\n    const el = event.currentTarget;\n    for (const [tag, type, method] of parseElementTags(el, 'data-action', parseActionAttribute)) {\n        if (event.type === type) {\n            const controller = el.closest(tag);\n            if (actionables.has(controller) && typeof controller[method] === 'function') {\n                controller[method](event);\n            }\n            const root = el.getRootNode();\n            if (root instanceof ShadowRoot) {\n                const shadowController = root.host;\n                if (shadowController.matches(tag) && actionables.has(shadowController)) {\n                    if (typeof shadowController[method] === 'function') {\n                        shadowController[method](event);\n                    }\n                }\n            }\n        }\n    }\n}\nexport const actionable = createAbility((Class) => class extends controllable(Class) {\n    constructor() {\n        super();\n        actionables.add(this);\n        observeElementForTags(this);\n    }\n    [attachShadowCallback](root) {\n        super[attachShadowCallback]?.(root);\n        observeElementForTags(root);\n    }\n});\n//# sourceMappingURL=actionable.js.map","import { targetable } from './targetable.js';\nimport { attrable } from './attrable.js';\nimport { actionable } from './actionable.js';\nimport { register } from './register.js';\n/**\n * Controller is a decorator to be used over a class that extends HTMLElement.\n * It will automatically `register()` the component in the customElement\n * registry, as well as ensuring `bind(this)` is called on `connectedCallback`,\n * wrapping the classes `connectedCallback` method if needed.\n */\nexport function controller(Class) {\n    return register(actionable(attrable(targetable(Class))));\n}\n//# sourceMappingURL=controller.js.map","import { dasherize } from './dasherize.js';\n/**\n * Register the controller as a custom element.\n *\n * The classname is converted to a approriate tag name.\n *\n * Example: HelloController => hello-controller\n */\nexport function register(classObject) {\n    const name = dasherize(classObject.name).replace(/-(element|controller|component)$/, '');\n    try {\n        window.customElements.define(name, classObject);\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        window[classObject.name] = customElements.get(name);\n    }\n    catch (e) {\n        // The only reason for window.customElements.define to throw a `NotSupportedError`\n        // is if the element has already been defined.\n        if (!(e instanceof DOMException && e.name === 'NotSupportedError'))\n            throw e;\n    }\n    return classObject;\n}\n//# sourceMappingURL=register.js.map"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","closestShadowPiercing","el","tagName","closest","shadow","getRootNode","ShadowRoot","host","SuppressedError","parseElementTags","tag","parse","getAttribute","trim","split","map","tagPart","registry","Map","observer","MutationObserver","mutations","mutation","type","attributeName","Element","has","found","get","meta","controller","addedNodes","node","observeElementForTags","registerTag","Error","set","root","querySelectorAll","hasAttribute","observe","ownerDocument","childList","subtree","attributeFilter","Array","from","keys","getPropertyDescriptor","instance","descriptor","getPrototypeOf","getType","value","createMark","validate","initialize","marks","WeakMap","proto","parent","Set","marker","name","kind","add","static","Symbol","getMarks","constructor","access","configurable","writable","enumerable","newDescriptor","assign","abilityMarkers","createAbility","Class","markers","NewClass","newMarkers","attachShadowCallback","attachInternalsCallback","shadows","internals","internalsCalled","WeakSet","controllable","args","super","shadowRoot","this","attachInternals","connectedCallback","setAttribute","attachShadow","elementInternals","dasherize","str","String","description","replace","toLowerCase","targetChangedCallback","targetsChangedCallback","getTarget","initializeTarget","selector","find","findTarget","join","call","targets","getTargets","initializeTargets","setTarget","controllers","many","nodes","push","targetable","attrChangedCallback","Identity","v","setFromMutation","attrs","attr","getAttr","initializeAttrs","dashed","includes","DOMException","mustDasherize","initialValue","cast","setCallback","getCallback","Number","Boolean","queue","newValue","isInitial","same","is","async","size","Promise","resolve","changed","clear","requestAttrChanged","attrable","isConnected","toggleAttribute","parseActionAttribute","eventSep","lastIndexOf","methodSep","Math","max","slice","event","addEventListener","handleEvent","actionables","currentTarget","method","shadowController","matches","actionable","classObject","window","customElements","define","e","register"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}